# Reef.Regen — Attestation Wizard (Step-by-step)

**Focus:** robust state management, local persistence, abort warnings, auth gate, and Step 1 (Regen Actions)

---

## 1) Goals & Scope

* Replace the single-page form with a **multi-step wizard** to reduce cognitive load.
* **Remember** everything the user selects/types across steps and page reloads.
* **Warn** before closing tab or navigating away mid-flow.
* **Gate** the flow behind sign-in + onboarding.
* Provide a **progress bar**, step content area, and a shared **Button Kit**.
* Step 1 pulls options from DB and supports **multi-select** with “default grey” vs “selected orange ✓”.

> Implementation here focuses on client state & persistence. Submission, EAS signing/relaying, and draft write-backs can reuse the current single-page logic after step mapping (see §9). 

---

## 2) Routes & Guards

* **Entry:** `/submit`
  – If not authenticated or missing onboarding profile, render the **Sign-in required** screen (image #1) with CTA to onboarding.
  – If authenticated, redirect to `/submit/steps/1`.
* **Steps:** `/submit/steps/[n]` where `n ∈ [1..N]`
* **Return-to:** append `?returnTo=/submit/steps/1` when sending users to onboarding.

**Route Guard (client):**

```ts
// app/submit/steps/[n]/page.tsx
export default withAuthAndOnboardingGuard(StepPage); // redirects + shows SI screen when needed
```

---

## 3) State Model (single source of truth)

Create a **Zustand** store with `persist` middleware (localStorage) to autosave the wizard state, including current step. This isolates step UIs from storage details and lets us hydrate from disk.

```ts
// lib/wizard/attestationWizardStore.ts
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

export type WizardState = {
  // core fields (mapped from AttestationForm today)
  organizationName: string;
  reefRegenActions: string[];        // Step 1
  actionDate?: string;               // Step 2
  siteId?: string; siteName?: string; siteType?: string; // Step 3
  lat?: string; lng?: string; depth?: string; area?: string;
  biodiversity: string[]; speciesCsv?: string;           // Step 4
  summary?: string; contributorsCsv?: string;            // Step 5
  fileCid?: string; fileUrl?: string; fileName?: string;

  // EAS
  schemaUid?: string; recipient?: string; deadline?: number;

  // meta
  currentStep: number; totalSteps: number; version: number;
  lastSavedAt?: number;
};

const DEFAULTS: WizardState = {
  organizationName: "",
  reefRegenActions: [],
  biodiversity: [],
  currentStep: 1,
  totalSteps: 5,
  version: 1
};

export const useAttestationWizard = create<WizardState>()(
  persist(
    (set, get) => ({
      ...DEFAULTS,
      setPatch: (patch: Partial<WizardState>) => set({ ...patch, lastSavedAt: Date.now() }),
      reset: () => set({ ...DEFAULTS, lastSavedAt: Date.now() })
    }) as WizardState & { setPatch(p: Partial<WizardState>): void; reset(): void; },
    {
      name: 'reefregen.attestation.wizard.v1', // versioned key for migrations
      storage: createJSONStorage(() => localStorage),
      partialize: (s) => s, // or whitelist fields if needed
    }
  )
);
```

**Migration strategy:** bump the key (`.v2`) when schema changes. On mount, if old keys exist, read, transform, and write to the new store, then delete old.

---

## 4) Autosave & Debounce

* Call `setPatch()` on any field change.
* For textareas/inputs, **debounce 250ms** before calling `setPatch`. Buttons and discrete selections can save immediately.
* Show a tiny “Saved • 2:14 PM” helper near the Next button when `lastSavedAt` updates.

---

## 5) Recovery & Clearing

* On load of any step, hydrate from Zustand (which pulls localStorage).
* On **successful final submission**, call `reset()` and optionally remove the storage key to prevent stale resumes.

---

## 6) Abort / Navigation Warnings

* **Browser/tab close:** attach `beforeunload` if `currentStep < totalSteps` and there are unsaved/dirty changes (we can track “dirty” by comparing against `DEFAULTS` or having a `hasEdits` flag when any field changes).
* **In-app navigation:** show a modal “You have an in-progress submission. Leave anyway?” whenever the router attempts to go elsewhere. Provide “Stay” (default) and “Leave”.

```ts
useEffect(() => {
  const handler = (e: BeforeUnloadEvent) => {
    if (hasUnsavedWork()) { e.preventDefault(); e.returnValue = ""; }
  };
  window.addEventListener('beforeunload', handler);
  return () => window.removeEventListener('beforeunload', handler);
}, [/* deps that reflect dirty state */]);
```

---

## 7) Progress Bar & Button Kit

* **Progress bar** reads `currentStep` / `totalSteps` from store and renders 5 segments.
* **Button Kit**

  * First step: `Next` only.
  * Middle steps: `Back` & `Next`.
  * Final step: `Sign & Submit`.
  * All buttons disabled during async work; show inline “Saving…” / “Uploading…” when needed.
* Keep the **sticky footer** with buttons so it’s always visible.

---

## 8) Step 1 — “What regen action are we submitting today?”

**Data source:** `GET /api/regen-types` → `{ id, name }[]`.
**UI:** cards in groups (Asexual, Sexual, Substratum Enhancement).
**Selection logic:** toggle on click; **grey** (default) vs **orange with ✓** (selected).
**Store updates:** `reefRegenActions: string[]`.

```tsx
function Step1Actions() {
  const { reefRegenActions, setPatch } = useAttestationWizard();
  const [options, setOptions] = useState<{id:number; name:string; group:string}[]>([]);
  useEffect(() => { fetch('/api/regen-types').then(r=>r.json()).then(j=>setOptions(j.items||[])); }, []);

  const toggle = (name: string) =>
    setPatch({ reefRegenActions: reefRegenActions.includes(name)
      ? reefRegenActions.filter(n => n !== name)
      : [...reefRegenActions, name] });

  return (
    <>
      <ProgressBar />
      <h1>What regen action are we submitting today?</h1>
      <p>You can select multiple actions that you have done</p>
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {options.map(opt => {
          const selected = reefRegenActions.includes(opt.name);
          return (
            <button key={opt.id} onClick={() => toggle(opt.name)}
              className={selected ? "card selected" : "card default"}>
              <span>{opt.name}</span>{selected && <span className="check">✓</span>}
            </button>
          );
        })}
      </div>
      <WizardFooter
        backVisible={false}
        onNext={() => setPatch({ currentStep: 2 })}
        nextDisabled={!reefRegenActions.length}
      />
    </>
  );
}
```

> The same endpoint and field names are already used by the current single-page form (`reefRegenActions`), so Step 1 can be wired without backend changes. 

---

## 9) Mapping from current form to steps

We’ll **reuse** the existing data model and submit pipeline. Break the current fields into steps so the final submit can still call the existing encode/sign/relay flow.

| Step | Fields (from store)                                                          | Notes                                                                                                |
| ---- | ---------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| 1    | `reefRegenActions[]`                                                         | From `/api/regen-types`. Multi-select cards.                                                         |
| 2    | `actionDate`, `summary`                                                      | Date + short text. (Allow range string like `YYYY-MM-DD ~ YYYY-MM-DD` if provided.)                  |
| 3    | `siteId` → hydrated to `siteName`, `siteType`, `lat`, `lng`, `depth`, `area` | Dropdown of user sites (`/api/sites/by-wallet`). Read-only lat/lng displayed (lon,lat schema later). |
| 4    | `biodiversity[]`, `speciesCsv?`                                              | Search-as-you-type + selectable chips (`/api/taxa/search`), plus optional CSV fallback.              |
| 5    | `contributorsCsv?`, evidence file (`fileCid`, `fileUrl`, `fileName`)         | File upload before signing to ensure CID is included.                                                |

**Submission step:** build encoded data and call **the same EAS delegated relay** logic. To avoid duplication, move the encoder + relay bits from `AttestationForm.tsx` into a shared client helper, e.g. `lib/wizard/attestationSubmit.ts` (encode, upload file, sign, relay, then clear store). 

---

## 10) Auth & Onboarding Gate

* Wrap the steps layout in `withAuthAndOnboardingGuard`:

  * If **not logged in** → render the **Sign-in screen** (image #1) with CTA to “Sign in now”, and secondary link “view sample”.
  * If logged in but missing `profile_name` (from `/api/profiles/me`) → redirect to onboarding flow.
  * Otherwise render the wizard.

---

## 11) Persistence Details

* **Storage key:** `reefregen.attestation.wizard.v1`
* **When to write:** any field change (`setPatch`) + step change.
* **What to write:** full `WizardState`.
* **Cleanup:** on success or if user explicitly clicks “Discard draft”.
* **Security:** data is non-sensitive; localStorage is acceptable. For future sensitive fields, switch to IndexedDB with encryption (out of scope here).

---

## 12) File Upload Timing

* Persist **selected file name** in store for UX continuity.
* Upload to storage at **final step before signing** so we embed CID in EAS payload and store CID/URL in DB (this mirrors the current form flow). Provide optimistic UI with spinner and retry. 

---

## 13) Error States & Resilience

* If any fetch fails (regen types, sites, taxa), show a non-blocking toast + retry button. The user can still navigate steps that don’t depend on that data.
* If upload fails, keep the file selection in state and allow **Retry**.
* If signing is rejected, keep all state and show inline “Signature was declined”.

---

## 14) Components to Build

* `withAuthAndOnboardingGuard` (HOC / wrapper)
* `WizardLayout` (header with logo + progress bar; content outlet; sticky footer)
* `ProgressBar` (5 segments)
* `WizardFooter` (Back/Next/Submit; saved-at indicator)
* `Step1Actions`, `Step2Details`, `Step3Site`, `Step4Biodiversity`, `Step5Evidence`
* `LeavePageGuard` (router prompt + beforeunload)
* Shared helpers:

  * `attestationSubmit.ts` (encode → upload → sign → relay → db updates) 
  * `useDebouncedSetter` for inputs
  * `formatters.ts` (date/range helpers)

---

## 15) Analytics & Telemetry (optional)

* Track step views, validation errors, and abandon events (when beforeunload fires with non-empty state).
* Measure completion rate per step to refine UX.

---

## 16) Testing Checklist

* Resume after reload at each step (data intact).
* Warning appears on tab close and when clicking site nav links.
* Step 1 multi-select UX matches design (grey ↔ orange ✓).
* Auth gate:

  * logged out → sign-in screen
  * logged in but no `profile_name` → onboarding
  * logged in + onboarded → step 1
* Final submit: evidence file uploaded, CID included in encoded data, relay returns UID, local draft cleared, store resets. 

---

## 17) Deliverables

* `lib/wizard/attestationWizardStore.ts` (Zustand + persist)
* New routes: `/submit/steps/[n]` with step components
* Guard, progress bar, button kit, leave-page guard
* Shared submission helper that reuses current form’s encode/relay path

---

## 18) Notes on Reuse from Current Form

* The single-page component already implements:
  – **schema encoding**, **file upload before sign**, **delegated sign + relay**, **draft DB writes**, and **species/site/regen-type fetching**. Extract these into shared helpers and call them from the wizard’s final step to avoid regressions. 

