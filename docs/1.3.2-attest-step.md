# Reef.Regen — Attestation Wizard · **Step 2: When & Where**

**Goal:** Implement the “When & Where did this happen?” step with:

* Date mode toggle (**specific date** vs **duration**)
* Site picker (choose existing, create new, or edit)
* MapLibre crosshair location selector for **creating** sites
* Strict client state + local persistence; safe abort handling

---

## 1) UX overview

### Layout

* Header: progress bar (segment 2 active) + title “When & Where did this happen?”
* Section A: **Action date**

  * Toggle pills: “On a specific date” | “On a duration”
  * If *specific*: single date input
  * If *duration*: start + end date inputs
* Section B: **Site**

  * If user has sites: list as **radio cards** (select 1). Each card shows name + type; trailing icons: ✎ (edit) and ⓘ tooltip for depth/area.
  * If no sites (or wants new): “Add a site” input/button opens **Create Site** modal.
* Footer (sticky): Back | Next

  * Next is disabled until **date(s)** valid **and** a **site** is chosen/created.

### Validation rules

* **Specific date**: required; saved as `actionDate` (ISO `YYYY-MM-DD`). DB writes `start_date = actionDate`, `end_date = null`.
* **Duration**: both required; `start_date <= end_date`. DB writes both. For EAS payload we concatenate: `"MM-DD-YYYY ~ MM-DD-YYYY"`.
* **Site**: required. For new site, all required except coordinates are chosen via map crosshair.
* Timezone hygiene: always read/write in **local date** (no time). On submit, serialize as `YYYY-MM-DD` strings (not UTC timestamps) to avoid TZ drift.

---

## 2) State model (Zustand persist)

Extends the store introduced in Step 1:

```ts
// Add/ensure fields in WizardState
{
  dateMode: 'single' | 'range',
  actionDate?: string,        // YYYY-MM-DD
  actionStart?: string,       // for range
  actionEnd?: string,         // for range

  siteId?: string,
  siteName?: string,
  siteType?: string,          // enum label or code
  siteDepthM?: number,
  siteAreaM2?: number,
  siteCoords?: [number, number], // [lon, lat]
}
```

**When user toggles date mode**, immediately persist `dateMode`, clear incompatible fields.
**When user selects a site**, persist all site fields (denormalize for display).
**When creating a site**, write to DB first, then hydrate the store with returned site.

---

## 3) API contracts

### 3.1 Sites

* `GET /api/sites/mine` → `[{ id, name, type, depth_m, area_m2, location: [lon,lat] }]`
* `POST /api/sites` (create)

  ```json
  {
    "name": "Koh Tao",
    "type": "Lab / Hatchery",         // or type_code
    "depth_m": 5,
    "area_m2": 167,
    "location": [99.841, 10.112]      // [lon, lat]
  }
  ```

  → `201 { id, ...payload }`
* `PATCH /api/sites/:id` (edit; **no coordinate changes**)

  ```json
  { "name": "...", "type": "...", "depth_m": 5, "area_m2": 167 }
  ```

### 3.2 Site type options

* `GET /api/site-types` → `[{ code, label }]`

---

## 4) Component breakdown

```
/submit/steps/2
  ├─ Step2DateSite.tsx
  │  ├─ DateModeToggle
  │  ├─ SingleDateInput | RangeDateInputs
  │  ├─ SitePicker
  │  │  ├─ SiteCard (radio)
  │  │  ├─ EditSiteModal (no coordinate edits)
  │  │  └─ CreateSiteModal
  │  │     └─ MapCrosshairPicker (MapLibre)
  │  └─ WizardFooter (Back, Next)
  └─ LeavePageGuard (beforeunload + route prompt)
```

---

## 5) Date inputs

* Use a simple date picker that returns **`YYYY-MM-DD`**.
* **Single mode**:

  * `dateMode='single'`, `actionDate` required.
* **Range mode**:

  * `dateMode='range'`, `actionStart` & `actionEnd` required.
  * Enforce `actionStart <= actionEnd`.
* Persist on change; show mini “Saved” timestamp.

---

## 6) Site picker (select / create / edit)

### 6.1 Selecting an existing site

* Render each site as a radio card:

  * Primary: `name`
  * Secondary: `type`
  * Small meta: `Depth: Xm · Area: Ym²`
  * Icons: ✎ (opens EditSiteModal), ⓘ (tooltip)
* On select, persist:

  ```
  siteId, siteName, siteType, siteDepthM, siteAreaM2, siteCoords
  ```

### 6.2 Creating a site (modal)

* Fields:

  * Name (text, required)
  * Type (select from `/api/site-types`, required)
  * Depth (meters, number ≥ 0, required)
  * Surface area (m², number ≥ 0, required)
  * **MapCrosshairPicker** (required coordinates)
* “Save” disabled until all fields valid and coordinates chosen.
* On save: `POST /api/sites` → add to local list + select it.

### 6.3 Editing a site (modal)

* Same UI minus the location picker.
* Coordinates **not editable** (show read-only `lon, lat`).
* On update: `PATCH /api/sites/:id`, update list + selection.

---

## 7) MapLibre crosshair location selector

### 7.1 UX behavior

* The **map moves**, the crosshair stays fixed at the center.
* Current coordinates (lon, lat) display under the map and update on `move` (throttled).
* Actions:

  * **Use this location** (primary): writes `[lon, lat]` to a local state in the modal.
  * Zoom controls `+ / −`, optional geolocate (“Use my location”).
* Style: same dark theme as the app. Disable rotation to keep orientation simple.

### 7.2 Implementation sketch

```tsx
import maplibregl from 'maplibre-gl';

function MapCrosshairPicker({ initial, onPick }: {
  initial?: [number, number];         // [lon, lat]
  onPick: (coords: [number, number]) => void;
}) {
  const mapRef = useRef<maplibregl.Map | null>(null);
  const containerRef = useRef<HTMLDivElement | null>(null);
  const [center, setCenter] = useState<[number, number]>(initial ?? [100.0, 10.0]);

  useEffect(() => {
    if (!containerRef.current) return;

    const map = new maplibregl.Map({
      container: containerRef.current,
      style: 'https://demotiles.maplibre.org/style.json',
      center: center,
      zoom: initial ? 9 : 3,
      pitch: 0,
      bearing: 0,
      dragRotate: false,
      touchZoomRotate: true,
      attributionControl: false
    });
    mapRef.current = map;

    // Controls
    map.addControl(new maplibregl.NavigationControl({ showCompass: false }), 'bottom-right');

    // Optional geolocate
    const geolocate = new maplibregl.GeolocateControl({ trackUserLocation: false });
    geolocate.on('geolocate', (e) => {
      const next: [number, number] = [e.coords.longitude, e.coords.latitude];
      map.flyTo({ center: next, zoom: 12 });
      setCenter(next);
    });
    map.addControl(geolocate, 'bottom-right');

    // Track center
    const update = () => {
      const c = map.getCenter();
      setCenter([+c.lng.toFixed(6), +c.lat.toFixed(6)]);
    };
    map.on('load', update);
    map.on('move', throttle(update, 50));
    return () => map.remove();
  }, []);

  return (
    <div className="relative">
      <div ref={containerRef} className="h-64 w-full rounded-2xl overflow-hidden" />
      {/* Crosshair overlay */}
      <div className="pointer-events-none absolute inset-0 grid place-items-center">
        <svg width="36" height="36" viewBox="0 0 36 36">
          <circle cx="18" cy="18" r="2" fill="currentColor" />
          <path d="M18 0v8M18 28v8M0 18h8M28 18h8" stroke="currentColor" strokeWidth="2"/>
        </svg>
      </div>

      <div className="mt-3 text-sm opacity-80">
        <code>{center[0]}, {center[1]}</code> <span className="ml-2">[lon, lat]</span>
      </div>

      <div className="mt-4 flex justify-end">
        <button className="btn btn-primary"
          onClick={() => onPick(center)}>
          Use this location
        </button>
      </div>
    </div>
  );
}
```

**Notes**

* Coordinates displayed/store as **[lon, lat]** (GeoJSON order).
* For keyboard accessibility, allow arrow keys to pan (`map.keyboard.enable()` is on by default).
* If you want a basemap with bathymetry later, swap the `style` URL.

---

## 8) Data flow & persistence

1. **Entering step 2**

   * Hydrate from store: if `dateMode` missing, default to `'single'`.
   * Prefill date(s)/site selection if present.
   * Fetch `/api/sites/mine` and `/api/site-types` in parallel.
2. **User actions**

   * Any change calls `setPatch({...})` (debounced for text fields).
   * Creating site → after `POST`, push into local array, select it, and `setPatch(...)`.
   * Editing site → after `PATCH`, update list and the selected card + store.
3. **Next button enablement**

   * `dateMode=single` → `actionDate` truthy
   * `dateMode=range` → `actionStart && actionEnd && start<=end`
   * `siteId` truthy
4. **Leaving the page**

   * `LeavePageGuard` active if any of the following are set: date(s), siteId (i.e., not pristine).
5. **On final submit (in Step 5)**

   * DB: `start_date`, optional `end_date`, `site_id`
   * EAS payload date field:

     * single: `"MM-DD-YYYY"`
     * range: `"MM-DD-YYYY ~ MM-DD-YYYY"`

---

## 9) Edge cases

* **Duration with same start/end** → allowed; treat as one-day duration in EAS string.
* **Switching from range→single** → clear `actionStart`/`actionEnd`, require `actionDate`.
* **Switching from single→range** → set `actionStart = actionDate`, `actionEnd = actionDate` as a convenience.
* **User cancels Create Site** → retain any typed values inside the modal (modal-local state), but don’t persist to store.
* **Site list empty after deletion elsewhere** → show “No sites yet” empty state + “Add a site” CTA.
* **Map load failure** → show retry button; allow manual lon/lat entry as fallback (optional).

---

## 10) Styling tokens & interactions

* **Selected site card** uses the orange style with a checkmark (matches Step 1).
* Inputs have the same focus states and rounded corners as the rest of the wizard.
* All primary actions inside modals use the orange primary button.

---

## 11) QA checklist

* Toggle between date modes retains values as described.
* Date validation prevents Next when invalid; show inline messages.
* Persisted state survives reload and browser restarts.
* Creating a site:

  * Cannot save without using the map to pick coordinates.
  * Location saved as `[lon, lat]`.
  * After save, card appears selected.
* Editing a site:

  * Coordinate fields not editable.
  * Updated fields reflected in list and store.
* Abort prompt appears on page close or in-app navigation with edits.
* Keyboard & screen-reader labels present for all controls (date inputs, toggle, radio cards, modal buttons).

---

## 12) Submit mapping (for later step)

When assembling the final **EAS payload**:

* `dateStr = (dateMode==='single') ? fmtMMDDYYYY(actionDate) : fmtMMDDYYYY(actionStart)+' ~ '+fmtMMDDYYYY(actionEnd)`
* `location = [lon, lat]` from `siteCoords`
* Include `siteName`, `siteType`, `depth_m`, `area_m2` as separate fields for DB convenience (EAS keeps the minimal required subset per schema).

---

If you want, I can turn this spec into a scaffold (components + store wiring + MapLibre picker) ready to paste into your Next.js repo.
